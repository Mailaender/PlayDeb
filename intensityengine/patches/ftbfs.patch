Index: intensityengine-1.1.6/src/thirdparty/v8/src/objects.h
===================================================================
--- intensityengine-1.1.6.orig/src/thirdparty/v8/src/objects.h	2012-10-20 16:27:48.863473000 +0200
+++ intensityengine-1.1.6/src/thirdparty/v8/src/objects.h	2012-10-21 12:36:58.958770733 +0200
@@ -2228,24 +2228,24 @@
 
   // Returns the value at entry.
   Object* ValueAt(int entry) {
-    return get(HashTable<Shape, Key>::EntryToIndex(entry)+1);
+    return this->get(HashTable<Shape, Key>::EntryToIndex(entry)+1);
   }
 
   // Set the value for entry.
   void ValueAtPut(int entry, Object* value) {
-    set(HashTable<Shape, Key>::EntryToIndex(entry)+1, value);
+    this->set(HashTable<Shape, Key>::EntryToIndex(entry)+1, value);
   }
 
   // Returns the property details for the property at entry.
   PropertyDetails DetailsAt(int entry) {
     ASSERT(entry >= 0);  // Not found is -1, which is not caught by get().
     return PropertyDetails(
-        Smi::cast(get(HashTable<Shape, Key>::EntryToIndex(entry) + 2)));
+        Smi::cast(this->get(HashTable<Shape, Key>::EntryToIndex(entry) + 2)));
   }
 
   // Set the details for entry.
   void DetailsAtPut(int entry, PropertyDetails value) {
-    set(HashTable<Shape, Key>::EntryToIndex(entry) + 2, value.AsSmi());
+    this->set(HashTable<Shape, Key>::EntryToIndex(entry) + 2, value.AsSmi());
   }
 
   // Sorting support
@@ -2268,7 +2268,7 @@
 
   // Accessors for next enumeration index.
   void SetNextEnumerationIndex(int index) {
-    fast_set(this, kNextEnumerationIndexIndex, Smi::FromInt(index));
+    this->fast_set(this, kNextEnumerationIndexIndex, Smi::FromInt(index));
   }
 
   int NextEnumerationIndex() {
Index: intensityengine-1.1.6/src/thirdparty/v8/src/utils.h
===================================================================
--- intensityengine-1.1.6.orig/src/thirdparty/v8/src/utils.h	2012-10-20 16:27:48.959473000 +0200
+++ intensityengine-1.1.6/src/thirdparty/v8/src/utils.h	2012-10-21 12:35:11.014773944 +0200
@@ -428,7 +428,7 @@
     if (this == &rhs) return *this;
     Vector<T>::operator=(rhs);
     memcpy(buffer_, rhs.buffer_, sizeof(T) * kSize);
-    set_start(buffer_);
+    this->set_start(buffer_);
     return *this;
   }
 
Index: intensityengine-1.1.6/src/thirdparty/v8/src/objects.cc
===================================================================
--- intensityengine-1.1.6.orig/src/thirdparty/v8/src/objects.cc	2012-10-20 16:27:48.863473000 +0200
+++ intensityengine-1.1.6/src/thirdparty/v8/src/objects.cc	2012-10-21 12:38:19.090768348 +0200
@@ -7431,7 +7431,7 @@
 
 template<typename Shape, typename Key>
 Object* Dictionary<Shape, Key>::AtPut(Key key, Object* value) {
-  int entry = FindEntry(key);
+  int entry = this->FindEntry(key);
 
   // If the entry is present set the value;
   if (entry != Dictionary<Shape, Key>::kNotFound) {
Index: intensityengine-1.1.6/src/engine/cubeloader.cpp
===================================================================
--- intensityengine-1.1.6.orig/src/engine/cubeloader.cpp	2012-10-20 16:27:48.311473000 +0200
+++ intensityengine-1.1.6/src/engine/cubeloader.cpp	2012-10-21 15:41:07.002442082 +0200
@@ -259,12 +259,12 @@
             else
             {
                 conoutf(CON_ERROR, "map %s has malformatted header", cgzname); 
-                gzclose(f); 
+                gzclose((gzFile)f); 
                 return; 
             }
         }
         else if(hdr.version>5) mod = true;
-        if(hdr.version>5 && !mod) { conoutf(CON_ERROR, "map %s requires a newer version of the Cube 1 importer", cgzname); gzclose(f); return; }
+        if(hdr.version>5 && !mod) { conoutf(CON_ERROR, "map %s requires a newer version of the Cube 1 importer", cgzname); gzclose((gzFile)f); return; }
         if(!haslocalclients()) game::forceedit("");
         emptymap(12, true, NULL);
         freeocta(worldroot);
@@ -280,7 +280,7 @@
         {
             hdr.waterlevel = -100000;
         }
-        if(mod) gzseek(f, hdr.numents*sizeof(c_persistent_entity), SEEK_CUR);
+        if(mod) gzseek((gzFile)f, hdr.numents*sizeof(c_persistent_entity), SEEK_CUR);
         else loopi(hdr.numents)
         {
             c_persistent_entity e;
